<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>vSarvaPhraseAuto Analysis</title>
    <link rel="stylesheet" href="style.css">

    <!--MIDI -->
    <script
        src="https://cdn.jsdelivr.net/combine/npm/tone@14.7.58,npm/@magenta/music@1.23.1/es6/core.js,npm/focus-visible@5,npm/html-midi-player@1.4.0"></script>
    <script
        src="https://cdn.jsdelivr.net/combine/npm/tone@14.7.58,npm/@magenta/music@1.23.1/es6/core.js,npm/focus-visible@5,npm/html-midi-player@1.4.0"></script>


    <!-- Code Highlighiting.js for SC-->

    <!--    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/hybrid.min.css" /> -->
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.8/highlight.min.js"></script>
   <script src="C:\Users\taegg\Desktop\konnakol_Learning\dissertion on Konnakol\BlogKonnakol\Highlighting"></script>
    <script>
        document.addEventListener("DOMContentLoaded", event => {
            document.querySelectorAll("pre code").forEach(block => {
                hljs.highlightBlock(block);
            });
        });
    </script>

    <style>
        body {
            background: rgb(234, 232, 232);
            margin: 40px;
        }


        pre code {
            max-height: fit-content;
            /* trova il modo di dargli realmente il valore che ti serve*/
            padding: 10px 20px !important;
            border-radius: 4px;
            box-shadow: 0px 0px 13px 0px rgba(0, 0, 0, 0.6);
        }


    </style>

</head>

<body>
    <nav>
        <ul class="nav__links" >
            <li><a href="Outputs.html">Code Examples</a></li>
            <li><a href="index.html">SC Home </a></li>
            <li><a href="Applying Carnatic.html">Applying Carnatic Music to western culture</a></li>
            <li><a href="mora analysis.html">mora analysis</a></li>
           
        </ul>

    </nav>
    <main>
        <article class="rapido">

            <!--vSarvaPhraseAuto analysis-->
            <section>
                <h1>vSarvaPhraseAuto analysis</h1> <hr>
              

                <br><audio controls>
                    
                    <source src="audio/render_code_audio/vSarvaPhraseAuto.0.mp3" type="audio/mp3">
                </audio>    
                <p>Ho esposrtato una ripetizione di 2 volte per chiarezza nell'ascolto, in realtà genera una sola frase</p>
 <pre><code lang="supercollider">
// create a piece at 120 bpm, in Adi Thala, with a gati of 4

a = KonaTani.new(120, #["I4","O","O"], 4, argSynth:\MIDITranscribe);

// init MIDI and set the midi out device
MIDIClient.init;
a.midiOut = MIDIOut.newByName("loopMIDI Port", "loopMIDI Port");
// generate a phrase
x = a.gen.vSarvaPhraseAuto

// play it
x.play;



/*
vSarvaPhraseLength*gati: oneBeat: 0.5
maxBeats: 5.0
phraseLength: 4.0
16.0
oneBeat: 0.5
maxBeats: 5.0
phraseLength: 4.0
partsArray: [ 2, 3, 4 ]
Conversion to KonaWords:
[ Ta      , Ta       , Ta      , Ta      , Ta      , Ta       , Ta       ]
[ 0.5     , 0.75     , 0.5     , 0.5     , 0.5     , 0.75     , 0.5      ]

combineSimilar:
[ Ta      , Ta       , Ta      , Ta      , Ka      , Ta       , Ta       ]
[ 0.5     , 0.75     , 0.5     , 0.5     , 0.5     , 0.75     , 0.5      ]

randomMuteJati:

[ Ta      , Ta       , Ta      , Ta      , Ka      , Ta       , -        ]
[ 0.5     , 0.75     , 0.5     , 0.5     , 0.5     , 0.75     , 0.5      ]

-> KonaTime[ a KonaWord, a KonaWord, a KonaWord, a KonaWord, a KonaWord, KonaTime[ a KonaWord ] ]



x.postWord
[ Ta      , Ta       , Ta      , Ta      , Ka      , Ta       , -        ]
[ 0.5     , 0.75     , 0.5     , 0.5     , 0.5     , 0.75     , 0.5      ]
[ [ 1, 8 ], [ 3, 16 ], [ 1, 8 ], [ 1, 8 ], [ 1, 8 ], [ 3, 16 ], [ 1, 8 ] ]

-> [ [ Ta      , Ta       , Ta      , Ta      , Ka      , Ta       , -        ], [ 0.5     , 0.75     , 0.5     , 0.5     , 0.5     , 0.75     , 0.5      ], [ [ 1, 8 ], [ 3, 16 ], [ 1, 8 ], [ 1, 8 ], [ 1, 8 ], [ 3, 16 ], [ 1, 8 ] ] ]


Ta 0.5 Ta 0.75 Ta 0.5 Ta 0.5 ka 0.5 Ta 0.75 - 0.5 -> KonaTime[ a KonaWord, a KonaWord, a KonaWord, a KonaWord, a KonaWord, KonaTime[ a KonaWord ] ]


*/
</code></pre>

        

<h1>Sarvalaghu  Generator</h1> <hr>

<p>
This project has focused on the vilamba kala sarvalaghu styles of the
ﬁve tani avartanams in Nelson (1991) <br> 
Dalle analisi è emerso che esista una frase archetipica che viene rielaborata  attraverso l'improvvisazione. <br>
<img src="images/img 5.23.PNG" alt="5.23"> <br>

Alcune volte dalla prima improvvisazione emerge materiale interessante che diventa il nuovo.
<img src="images/img 5.24.PNG" alt="5.24"> 


<br> Esistono forme musicali/cadenze ritmiche ricorrenti tipo il korvai:
<iframe width="560" height="315" src="https://www.youtube.com/embed/Bf5Qq3CXTV0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

  <br>
  <p> Kanakku is used for cadential purposes, and is a broad term
   for the various loosely deﬁned forms mora, arudi, tırmanam, korvai, and ta din gi n.a tom (Nelson, 1991, vol.1 p.43). <br>
   sarvalaghu patterns are the time-keeping structures that reinforce the ﬂow of the t¯al.a <br></p>


<p> Sarvalaghu patterns vary between musicians and contexts. For example, in
the vilamba kala stages of a tani avartanam the patterns tend to use two m¯atra syllables/strokes with
accents on the beat or half beat, while in the madhyama k¯ala section one m¯atra syllables/strokes are
used with accents on any pulse in the beat</p>

<h2>Phrase Length</h2>
<p>La durata delle frasi è stata stabilita in base alla capacità della nostra memoria a breve termine between 2 and 3.375 seconds 
<br>     

<h2>vSarvaPhraseLength</h2> 
<p> E' stato scritto per darci in beat una durata che rientri nei parametri.
Then ﬁnd the longest phrase length that ﬁts neatly into the tala once or in multiples of two. <br>
vSarvaPhraseLength serve a calcolare il numero massimo di battute per una frase che viene calcolato utilizzando il tempo assoluto 
per una battuta e il massimo tempo cognitivo (currently uses a window of 5 seconds.) aAl di la di questo il numenro massimo di beats in un a frase è di 5 beats.
vSarvaPhraseLength quindi trova la lunghezza della frase più lunga che si adatta perfettamente al tala una volta o in multipli di due.
</p>

<pre><code lang="supercollider"> 
   /* ================= */
   /* = Music Methods = */
   /* ================= */


//	vSarvaPhraseLength
//	Method to determine the phrase length (in beats)
//		for sarvalaghu patterns for the Vilamba Kala section
//	Uses a tweaked perceptual present model,
//		currently uses a window of 5 seconds.
vSarvaPhraseLength {
var phraseLength;
var oneBeat;
var maxBeats;
var val;
//Time in seconds for one beat
oneBeat = 60/laya;
Post << "oneBeat: " <<  oneBeat << "\n";

//The number of beats that can fit into the maximum perceptual time
//With a maximum number of beats of 5. Even if perceptual time is 3 seconds,
//	phrases are not usually longer than this
maxBeats = (pMax/oneBeat).min(5);
Post << "maxBeats: " <<  maxBeats << "\n";

//	This algorithm attempts to find that largest phrase length that
//	fits neatly into a full cycle.
//	At the moment this only works in terms of half/quarter/eigth cycles etc
//	Could be adapted to find other durations of phrase that
//	can fit neatly into a cycle
//	E.g. a 9 beat tala could be made up of 3 * 3 beat phrases
//	Not a huge amount of material to support this theory.

phraseLength = 0;
val = tala.sum;

while({phraseLength==0},
{
phraseLength = maxBeats-(maxBeats%val);
val = val/2;
}
);

Post << "phraseLength: " <<  phraseLength << "\n";

^phraseLength
}
</code></pre>

<h2>Phrase Generation</h2>
<p>E' diviso in due metodi,il primo vSarvaPhrase crea frasi in base a una data durata di frase in matras, e il successivo vSarvaPhraseAuto chiama semplicemente vSarvaPhrase passando i risultati del metodo vSarvaPhraseLength moltiplicato per il numero di gati.  
  <br> vSarvaPhrase serve a generare una frase fondamentale di Sarvalaghu, dalla quale si possono generare nuovi motivi e variazioni. <br>
  <img src="images/img 5.26.1PNG" alt="5.23"> 
  <img src="images/img 5.26.2.PNG" alt="5.26.2"> 
  <img src="images/img 5.26.3.PNG" alt="5.26.3"> 
  <img src="images/img 5.26.4.PNG" alt="5.26.4"> 
  <img src="images/img 5.26.6.PNG" alt="5.26.6"> 
  


 <br> In accordo con l'osservazione di Nelson (1991, vol.1 p.37) che i modelli nel
amba kala usa principalmente parole con due matra jatis, la dimensione minima della parte (per il partizionamento) è impostata su
Due. Il valore massimo è impostato su gati se la frase è lunga e la durata della frase, in caso contrario, 
l'array viene creato da questi valori, ad es. [2,3,4,5] per khanda gati. Una serie di pesi per ogni parte
la dimensione è costruita con pregiudizi per le dimensioni delle parti che sono incluse nella famiglia ritmica del gati. Per
khanda (cinque) e misra (sette) gati di dimensioni due e tre ricevono un'ulteriore distorsione a causa di 
la loro idoneità per i gati.
</p>


<pre><code lang="supercollider"> 
   //	vSarvaPhraseAuto
   //	Automation of vSarvaPhrase
   vSarvaPhraseAuto {

       "vSarvaPhraseLength*gati: ".post; (this.vSarvaPhraseLength*gati).postln;

       ^this.vSarvaPhrase(this.vSarvaPhraseLength*gati);
   }
</code></pre>
<p>vSarvaPhrase è stato scritto per generare le frasi fondamentali di sarvalaghu, dalle quali variazioni e nuovi motivi possono essere generati.
    vengono usate principalmente parole con 2 matras jatis, la partizione minima è settata a due.
    Il valore massimo dato alla partizione è settato in base al gati se la frase è lunga, 
</p>

<pre><code lang="supercollider"> 
//	vSarvaPhrase
//	Method to generate a phrase for the Vilamba section sarvalaghu
vSarvaPhrase {|phraseDur, aMin=2|
    var phraseMatras;
    var jatiParts;
    var min;
    var max;
    var partsArray, weights, maxW, maxW1, maxW2, maxW1MI;
    var muteChance;
    var ret;

    if(phraseDur%1!=0) {
        ret = KonaTime.new(tani);
        ret.add(this.vSarvaPhrase(phraseDur.floor, aMin));
        ret.add(KonaWord.new(1, gati, (phraseDur-phraseDur.floor)));
        ^ret;
    };

    phraseMatras = phraseDur;

    if(phraseDur<aMin) {
        min = phraseDur;
    } {
        min = aMin;
    };

    if(2*gati<=phraseDur) {
        max = gati;
    } {
        max = phraseDur;
    };

    //Possible part sizes
    partsArray = (min..max);
    Post << "partsArray: " <<  partsArray << "\n";

    //Parts 2 to gati. Given heaviest weightings
    weights = Array.fill(partsArray.size, 0);

    weights.size.do { |i|

        if(this.gatiPowers.includes(partsArray[i]),
            {weights[i] = 1.5},
            {weights[i] = 0.4}
        );

        if(partsArray[i]<gati) {
            weights[i] = weights[i] + 0.25;
        } {
            if(partsArray[i]!=gati) {
                    weights[i] = weights[i] - 0.4
            };
        };

        if(gati==5 || (gati==7)) {
            if((partsArray[i]== 3) || (partsArray[i]== 2)) {
                weights[i] = weights[i] + 0.25;
            } {
                weights[i] = weights[i] - 0.25
            };
        };

        if(weights[i]<0,
            {weights[i] = 0}
        );

    };
    //Scale and invert values.
    weights = (weights/weights.maxItem-1).round(0.01).abs;

    jatiParts = this.allPartitions(phraseMatras.asInteger, aMax: max);

    jatiParts = this.removeGreaterThan(jatiParts, 4);

    jatiParts = this.removeThoseContaining(jatiParts, partsArray, weights);

    jatiParts = jatiParts.choose;

    jatiParts = this.randomPerm(jatiParts);

    ret = KonaTime.new(tani);
    jatiParts.size.do { |i|
        if((jatiParts[i].even && (jatiParts[i]>2)) && 0.75.coin ) {
            ret.add(KonaWord.new(jatiParts[i]/2, gati, 2, tani))
        } {
            ret.add(KonaWord.new(1, gati, jatiParts[i], tani))
        };
    };
    "Conversion to KonaWords: ".postln;ret.postWord(true, true, false);

    ret = this.combineSimilar(ret, 2, 4, 0.9);
    "combineSimilar: ".postln; ret.postWord(true, true, false);

    muteChance = 0.75;
    3.rand.do { |i|
        if(muteChance.coin) {
            ret = this.randomMuteJati(ret);
        };
        muteChance = muteChance/2;
    };
    "randomMuteJati: ".postln; ret.postWord(true, true, false);

    ^ret;

}

</code></pre>

<h2>Phrase Matras</h2>
<p> 
il metodo vSarvaPhrase viene chiamato in vSarvaPhraseAuto passando come argomento this.vSarvaPhraseLength*gati
The phraseMatras value is partitioned with allPartitions (passing in the maximum part size)
with any partition with more than four parts being removed by removeGreaterThan. Partitions with
particular part sizes are probabilistically removed by passing the array of part sizes and weights to
removeThoseContaining. A partition is randomly selected and ﬁnally permuted with randomPerm. A
custom transformation from integers to KonaWords then takes place; any even values greater than two
are given a 75% chance of being halved in terms of jatis and doubled in terms of karve (e.g. a four m¯atra
Ta becomes a two m¯atra per jati Ta ka), all other values become single jati (Ta) KonaWords with the
part number used for the karve. Finally the phrase is passed into combineSimilar with a maximum
combination size of four and some syllables are probabilistically muted to create variation (see Muting
Jatis in Section 5.3.4). 
Vengano utilizzati metodi per micromutazioni. 
</p>

<pre><code lang="supercollider">
^this.vSarvaPhrase(this.vSarvaPhraseLength*gati);

vSarvaPhrase {|phraseDur, aMin=2|
    var phraseMatras;
    var jatiParts;
    var min;
    var max;
    var partsArray, weights, maxW, maxW1, maxW2, maxW1MI;
    var muteChance;
    var ret;

    if(phraseDur%1!=0) {
        ret = KonaTime.new(tani);
        ret.add(this.vSarvaPhrase(phraseDur.floor, aMin));
        ret.add(KonaWord.new(1, gati, (phraseDur-phraseDur.floor)));
        ^ret;
    };

    phraseMatras = phraseDur;
</code></pre>
   
<pre><code lang="supercollider">
//partitions.scd

r = KonaGenerator.new();

KonaTani.new.gen.vSarvaPhraseLength;
/*
oneBeat: 1.0
maxBeats: 5.0
phraseLength: 4.0
-> 4.0
*/


KonaTani.new.gen.vSarvaPhraseAuto;

/*
vSarvaPhraseLength*gati: oneBeat: 1.0
maxBeats: 5.0
phraseLength: 4.0
16.0
oneBeat: 1.0
maxBeats: 5.0
phraseLength: 4.0
partsArray: [ 2, 3, 4 ]
Conversion to KonaWords:
[ Ta      , Ka      , Ta      , Ta      , Ka      , Ta      , Ka      , Ta       ]
[ 0.5     , 0.5     , 0.5     , 0.5     , 0.5     , 0.5     , 0.5     , 0.5      ]

combineSimilar:
[ Ta      , Ka      , Ta      , Ta      , Ka      , Di      , Mi      , Ta       ]
[ 0.5     , 0.5     , 0.5     , 0.5     , 0.5     , 0.5     , 0.5     , 0.5      ]

randomMuteJati:

[ Ta      , Ka      , Ta      , Ta      , -       , Ta      , Ka      , -        ]
[ 0.5     , 0.5     , 0.5     , 0.5     , 0.5     , 0.5     , 0.5     , 0.5      ]

-> KonaTime[ a KonaWord, a KonaWord, KonaTime[ a KonaWord, a KonaWord, a KonaWord ], KonaTime[ a KonaWord ] ]
*/
   </code></pre>

   <h2>Phrase Development</h2>
   <p>Come già detto è comune per una frase essere variata abbastanza da averene un'altra entità, questo viene fatto andando a chiamare mutatePhrase</p>
   <img src="images/img 5.24.PNG" alt="5.24"> 
<p>E' abbastanza chiaro che nello switch vi siano una serie di metodi "Macro Mutation" utilizzati per alterare larghi gruppi di materiali, 
    vengono utilizzati implicitamente anche i metodi che fanno parte delle "Micro Mutation" che possono venire richiamati, andando ad usare delle probabilità relative alla parola.
    A tutto questo aggiungiamo anche la possibilità di ricorsione.
</p>
<pre><code lang="supercollider">
//	mutatePhrase
//	Method to mutate a given phrase using many possible
//		combinations of automated manipulation methods
//
//	@aKonaItem Item to manipulate;
mutatePhrase {|aKonaItem, aChance, aRec=0.75, aNum|
    var col;		//	Input collection
    var ret;		//	Output collection
    var change;		//	The chance an item will be mutated;
    var min;		//	Minimum value for alteration
    var max;		//	Maximum value for alteration
    var val;		//	Variable used to calculate density possibilties
    var count;		//	Variable used when calculating density possibilities
    var index;		//	Index of element to mutate
    var store;		//	Array to store indexes to be removed (atDensity)
    var num;		//	Index of process to use;

    if(aKonaItem.class==KonaTime) {
        col = aKonaItem;
    } {
        col = KonaTime.newFrom([aKonaItem], tani);
    };

    change = aChance ?? {(1/col.size)*1.5};
    if(aNum==nil) {
        num = {5.rand}
    } {
        num = {aNum}
    };
    ret = KonaTime.new(tani);
    col.size.do { |i|
        if(change.coin,
            {
                if(col[i].class==KonaWord) {
                switch (num.())
                    {0}	{
                            ret.add(this.randomAtDensity(col[i]));
                        }
                    {1}	{
                            ret.add(this.randomExtendJati(col[i]));
                        }
                    {2}	{
                            ret.add(this.randomMuteJati(col[i]));
                        }
                    {3}	{
                            ret.add(this.randomDensityJati(col[i]));
                        }
                    {4}	{
                            ret.add(this.partitionWord(col[i]));
                        };
                } {
                    ret.add(this.mutatePhrase(col[i], aRec=aRec/4))
                };

            },
            {
                ret.add(col[i])
            }
        );
    };

    //Possible recursion for more mutation.
    if(aRec.coin) {
        ^this.mutatePhrase(ret, aRec:aRec/2, aNum:aNum)
    } {
        ^ret
    };
}
</code></pre>

<h2>Phrase Suﬃxes </h2>
<p>E' molto comune che le frasi di sarvalaghu finiscano con un suffisso, che conferisce varietà alla frase e serve ad introdurre cadenze ritmiche.</p>
<img src="images/img 5.28.PNG" alt="5.28"> 
<p>Si veda anche la mora S+G+S+G+S -> cocnlusione </p>
<img src="images/img 5.29.PNG" alt="5.29"> <br>


<h2>Statistical Generation </h2>
<p>
Statistical generation of sarvalaghu patterns were brieﬂy experimented with; a model was made of the ﬁrst
four cycles of Trichy S. Sankaran’s tani ¯avartanam in Nelson (1991, vol.3 p.162). This was implemented
in as the method vSarvaStat, but was not developed beyond a basic state.

<pre><code lang="supercollider">
//	vSarvaStat
//	A method for generating Sarva Laghu material based on
//		a statistical analysis of a performance by Trichy Sankaran;
//	Currently only works with an n of 1, no context.
vSarvaStat {
    var stats;
    var ret;

    ret = KonaTime.new(tani);

    stats = [
        100, 37.5, 87.5, 68.75,
        93.75, 12.5, 100, 25,

        100, 80, 100, 13,
        100, 13, 100, 6,

        100, 0, 73, 53,
        100, 0, 100, 22,

        89, 66, 100, 22,
        100, 30, 80, 30
    ];

    stats.size.do { |i|
        if((stats[i]/100).coin) {
            ret.add(KonaWord.new(1,4,1,tani))
        } {
            ret.add(KonaWord.new(0,4,1,tani))
        };
    };

    ^ret
}
</code></pre>    
</p>



</section>

        </article>
    </main>

</body>

</html>